列出异步处理架构，不要修改代码

⏺ 异步处理架构设计

  基于对代码的分析，我设计了以下异步处理架构来解决用户快速输入时的性能问题：

  1. 核心问题分析

  当前同步处理的瓶颈：
  - SquirrelInputController.swift:116 - processKey() 同步调用
  - SquirrelInputController.swift:386 - rimeAPI.process_key() 阻塞主线程
  - SquirrelInputController.swift:427 - rimeUpdate() 同步获取候选词

  2. 异步处理架构

  2.1 核心组件
  AsyncRimeProcessor - 异步处理器
  - 作用：将所有librime调用移到后台队列
  - 位置：新增文件 sources/AsyncRimeProcessor.swift
  - 线程模型：
    - 主线程：接收用户输入，立即返回
    - 后台队列：处理librime调用
    - 主线程回调：更新UI

  2.2 请求去重机制

  请求ID管理
  - 每个输入操作分配唯一ID
  - 只处理最新请求，丢弃过时请求
  - 避免过时结果覆盖最新状态

  处理流程：
  用户输入 → 生成RequestID → 后台处理 → 检查ID有效性 → 更新UI
          ↓
      立即返回true（不阻塞）

  2.3 核心方法改造

  异步方法：
  - processKeyAsync() - 替代同步的 processKey()
  - selectCandidateAsync() - 异步候选词选择
  - changePageAsync() - 异步翻页
  - setCaretPosAsync() - 异步光标移动

  同步方法保留：
  - getOption() / setOption() - 即时配置
  - clearComposition() - 立即清除
  - getInput() / getCaretPos() - 状态查询

  3. 修改点分析

  3.1 SquirrelInputController.swift 修改

  主要修改位置：
  - handle() 方法：使用异步处理器
  - processKey() 方法：改为异步调用
  - rimeUpdate() 方法：移至后台线程
  - selectCandidate() 方法：改为异步
  - page() 方法：改为异步

  3.2 线程安全保证

  锁机制：
  - requestIdLock - 保护请求ID生成
  - processingLock - 避免并发处理
  - 主线程回调确保UI更新安全

  3.3 状态管理

  即时反馈：
  - 用户输入立即返回，不等待处理
  - 预览状态可以显示正在处理
  - 最终结果异步更新

  一致性保证：
  - 按时间顺序处理请求
  - 丢弃过时的中间结果
  - 确保最终显示最新状态

  4. 性能优化策略

  4.1 请求合并

  - 连续快速输入时，只处理最后一个请求
  - 减少不必要的librime调用
  - 提高整体响应速度

  4.2 智能缓存

  - 缓存频繁查询的状态信息
  - 减少跨线程数据传递
  - 优化内存使用

  4.3 优先级队列

  - 用户交互操作优先级最高
  - 背景更新操作可延迟处理
  - QoS设置为 .userInteractive

  5. 用户体验改进

  预期效果：
  - ✅ 快速连续输入不卡顿
  - ✅ 界面响应即时
  - ✅ 只显示最终输入结果
  - ✅ 避免中间状态闪烁
  - ✅ 保持输入法功能完整性

  回退机制：
  - 保留原有同步方法作为备用
  - 异步处理失败时可降级到同步模式
  - 确保系统稳定性

  这个架构通过将librime的耗时操作移到后台，同时确保只处理最新的用户输入，能够显著改善快速输入时的用户体验。
